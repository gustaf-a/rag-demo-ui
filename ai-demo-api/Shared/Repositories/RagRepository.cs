using Microsoft.Extensions.Configuration;
using Npgsql;
using Shared.Models;
using System.Text;
using System.Text.Json;
using Shared.Models;
using Shared.Extensions;

namespace Shared.Repositories;

public class RagRepository : RepositoryBase, IRagRepository
{
    public RagRepository(IConfiguration configuration) : base(configuration)
    {
    }

    public async Task<IEnumerable<string>> GetTableNames()
    {
        string query = @"
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public'
              AND table_type = 'BASE TABLE';
        ";

        return await ExecuteQueryAsync<string>(
            query,
            []
        );
    }

    public async Task<IEnumerable<string>> GetUniqueMetaDataTagKeys(DatabaseOptions databaseOptions)
    {
        string query = $@"
            SELECT DISTINCT jsonb_object_keys(metadata->'Tags') AS unique_keys
            FROM {databaseOptions.TableName};
        ";

        return await ExecuteQueryAsync<string>(
            query,
            []
        );
    }

    public async Task<IEnumerable<string>> GetUniqueMetaDataTagValues(DatabaseOptions databaseOptions, string tag)
    {
        string query = $@"
            SELECT DISTINCT metadata->'Tags'->>'{tag}' AS tag_value
            FROM {databaseOptions.TableName}
            WHERE metadata->'Tags' ? '{tag}';
        ";

        return await ExecuteQueryAsync<string>(
            query,
            []
        );
    }

    public async Task ResetTable(DatabaseOptions databaseOptions)
    {
        await DeleteTable(databaseOptions);

        await CreateEmbeddingsTable(databaseOptions);
    }

    public async Task CreateEmbeddingsTable(DatabaseOptions databaseOptions)
    {
        string createTableQuery = $@"
            CREATE TABLE IF NOT EXISTS {databaseOptions.TableName} (
                id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                metadata JSONB,
                content TEXT,
                embeddingContent TEXT,
                startIndex BIGINT,
                endIndex BIGINT,
                embedding VECTOR({databaseOptions.EmbeddingsDimensions}) NOT NULL
            );";

        await ExecuteQuery(createTableQuery);
    }

    public async Task SetupIndex()
    {
        //TODO create index
        //        const string createDiskAnnQuery =
        //@"
        //CREATE EXTENSION IF NOT EXISTS pg_diskann CASCADE;
        //CREATE INDEX embeddings_diskann_idx ON embeddings USING diskann (embedding vector_cosine_ops);
        //";

        //        await ExecuteQuery(createDiskAnnQuery);
    }

    public async Task InsertData(DatabaseOptions databaseOptions, ContentChunk contentChunk, float[] embedding, EmbeddingMetaData metaData)
    {
        string insertQuery = $@"
            INSERT INTO {databaseOptions.TableName} (content, embedding, embeddingContent, startIndex, endIndex, metadata)
            VALUES (@content, @embedding, @embeddingContent, @startIndex, @endIndex, @metadata);";

        var metadataJson = JsonSerializer.Serialize(metaData);

        var embeddingsDouble = Array.ConvertAll(embedding, x => (double)x);

        using var connection = new NpgsqlConnection(_options.ConnectionString);
        await connection.OpenAsync();

        using var command = new NpgsqlCommand(insertQuery, connection);

        command.Parameters.AddWithValue("@content", contentChunk.Content);
        command.Parameters.AddWithValue("@embeddingContent", contentChunk.EmbeddingContent);
        command.Parameters.AddWithValue("@startIndex", contentChunk.StartIndex);
        command.Parameters.AddWithValue("@endIndex", contentChunk.EndIndex);
        command.Parameters.AddWithValue("@embedding", embeddingsDouble);
        command.Parameters.Add("@metadata", NpgsqlTypes.NpgsqlDbType.Jsonb)
               .Value = metadataJson;

        await command.ExecuteNonQueryAsync();
    }

    public async Task<IEnumerable<ContentChunk>> GetContentChunks(ContentChunkRequest contentChunkRequest)
    {
        var parameters = new Dictionary<string, object>
        {
            { "start_chunk", contentChunkRequest.StartChunk },
            { "end_chunk", contentChunkRequest.EndChunk },
            { "uri", contentChunkRequest.Uri.ToString() }
        };

        var query = $@"
                        SELECT *
                        FROM {contentChunkRequest.TableName.ToLower()}
                        WHERE (metadata->>'SourceChunkNumber')::int BETWEEN @start_chunk AND @end_chunk
                        AND metadata->>'Uri' = @uri
                    ";

        var queryResult = await ExecuteQueryAsync(
                            query,
                            parameters,
                            CreateEmbeddingsRowModelMapFunction
                          );

        if (queryResult == null || !queryResult.Any())
            return Enumerable.Empty<ContentChunk>();

        return queryResult.Select(qr => new ContentChunk(qr));
    }

    //public async Task<IEnumerable<ContentChunk>> GetContentChunks(ContentChunkRequest contentChunkRequest)
    //{
    //    //find all from contentChunkRequest.TableName
    //    //where the json object metadata property
    //    //SourceChunkNumber is between contentChunkRequest.StartChunk and contentChunkRequest.EndChunk
    //    //and the metadata property Uri is the same string as contentChunkRequest.Uri

    //    var query = "";
    //    var queryResult = await ExecuteQueryAsync(
    //                        query,
    //                        parameters,
    //                        CreateEmbeddingsRowModelMapFunction
    //                    );

    //    if (queryResult == null || !queryResult.Any())
    //        return Enumerable.Empty<ContentChunk>();

    //    return queryResult.Select(qr => new ContentChunk(qr));
    //}

    public async Task<IEnumerable<RetrievedDocument>> RetrieveData(string embeddingsTableName, PostgreSqlQueryParameters queryParameters)
    {
        ArgumentNullException.ThrowIfNull(queryParameters);

        var sqlBuilder = new StringBuilder();
        var whereClauses = new List<string>();
        var parameters = new Dictionary<string, object>();

        sqlBuilder.AppendLine("SELECT *");
        sqlBuilder.AppendLine($"FROM {embeddingsTableName}");

        if (!queryParameters.ContentMustIncludeWords.IsNullOrEmpty())
        {
            for (int i = 0; i < queryParameters.ContentMustIncludeWords.Count(); i++)
                AddColumnFilter(whereClauses, parameters, "content", isInclude: true, paramName: $"@TextQueryIncl{i}", queryParameters.ContentMustIncludeWords.ElementAt(i));
        }

        if (!queryParameters.ContentMustNotIncludeWords.IsNullOrEmpty())
        {
            for (int i = 0; i < queryParameters.ContentMustNotIncludeWords.Count(); i++)
                AddColumnFilter(whereClauses, parameters, "content", isInclude: false, paramName: $"@TextQueryExcl{i}", queryParameters.ContentMustNotIncludeWords.ElementAt(i));
        }

        if (!queryParameters.MetaDataFilterInclude.IsNullOrEmpty())
            whereClauses.AddRange(queryParameters.MetaDataFilterInclude);

        if (!queryParameters.MetaDataFilterExclude.IsNullOrEmpty())
            whereClauses.Add($"NOT ({string.Join(" OR ", queryParameters.MetaDataFilterExclude)})");

        if (whereClauses.Any())
            sqlBuilder.AppendLine("WHERE " + string.Join(" AND ", whereClauses));

        var embeddingsString = $"[{string.Join(',', queryParameters.EmbeddingQuery.Select(e => e.ToString()))}]";
        sqlBuilder.AppendLine($"ORDER BY embedding <=> '{embeddingsString}'");

        if (queryParameters.ItemsToSkip > 0)
        {
            sqlBuilder.AppendLine("LIMIT @ItemsToRetrieve OFFSET @ItemsToSkip");
            parameters.Add("@ItemsToRetrieve", queryParameters.ItemsToRetrieve);
            parameters.Add("@ItemsToSkip", queryParameters.ItemsToSkip);
        }
        else
        {
            sqlBuilder.AppendLine("LIMIT @ItemsToRetrieve");
            parameters.Add("@ItemsToRetrieve", queryParameters.ItemsToRetrieve);
        }

        var retrieveDataQuery = sqlBuilder.ToString();

        var queryResult = await ExecuteQueryAsync(
            retrieveDataQuery,
            parameters,
            CreateEmbeddingsRowModelMapFunction
        );

        if (queryResult == null || !queryResult.Any())
            return Enumerable.Empty<RetrievedDocument>();

        return queryResult.Select(qr => new RetrievedDocument(embeddingsTableName, qr));
    }

    private static void AddColumnFilter(List<string> whereClauses, Dictionary<string, object> parameters, string tableColumn, bool isInclude, string paramName, string word)
    {
        whereClauses.Add($"{(isInclude ? "" : "NOT ")}{tableColumn} ILIKE '%' || {paramName} || '%'");
        parameters.Add(paramName, word);
    }

    private static EmbeddingsRowModel CreateEmbeddingsRowModelMapFunction(NpgsqlDataReader reader)
    {
        var metadataJson = reader.GetString(reader.GetOrdinal("metadata")); // JSONB as JSON string

        var metadata = JsonSerializer.Deserialize<EmbeddingMetaData>(metadataJson);

        return new EmbeddingsRowModel
        {
            Id = reader.GetInt64(reader.GetOrdinal("id")),
            Metadata = metadata,
            Content = reader.GetString(reader.GetOrdinal("content")),
            EmbeddingContent = reader.GetString(reader.GetOrdinal("embeddingContent")),
            StartIndex = reader.GetInt64(reader.GetOrdinal("startIndex")),
            EndIndex = reader.GetInt64(reader.GetOrdinal("endIndex")),
            EmbeddingVector = null //Not relevant during retrieval
        };
    }
}
