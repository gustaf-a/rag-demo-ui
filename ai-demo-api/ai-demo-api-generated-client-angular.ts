//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * Creates an agent
     * @param body (optional) 
     * @return Success
     */
    agents(body: Agent | undefined): Observable<ProcessInfo>;
    /**
     * @return Success
     */
    agentsAll(): Observable<Agent[]>;
    /**
     * Creates and starts an agent task
     * @param body (optional) 
     * @return Success
     */
    task(body: StartAgentTaskRequest | undefined): Observable<AgentTask>;
    /**
     * @return Success
     */
    getTables(): Observable<string[]>;
    /**
     * @return Success
     */
    removeTable(tableName: string): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    resetTable(body: DatabaseOptions | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createEmbeddingsTable(body: DatabaseOptions | undefined): Observable<string>;
    /**
     * @return Success
     */
    getUniqueTagValues(tableName: string, tag: string): Observable<string[]>;
    /**
     * @return Success
     */
    getUniqueTagKeys(tableName: string): Observable<string[]>;
    /**
     * Gets a chat response.
    If SearchOptions are included, search results will be included for the model to use for generation.
    If ProvidedDocumentSources are included, they will be used instead of searching.
     * @param body (optional) 
     * @return Success
     */
    getChatResponse(body: ChatRequest | undefined): Observable<ChatResponse>;
    /**
     * Continues a chat using the chat history object.
    This is a bit experimental, but should allow human in the loop and/or step-by-step animations of what the model is doing in the background.
    When model is finished it will return an Assistant-message with content.
    If this chathistory is returned in another reply then code will see metaData:FinishReason:Stop and will return an empty chathistory object as a reply.
     * @param body (optional) 
     * @return Success
     */
    continueChat(body: ContinueChatRequest | undefined): Observable<ChatResponse>;
    /**
     * @return Success
     */
    getChunkers(): Observable<string[]>;
    /**
     * Imports and ingests data
     * @param body (optional) 
     * @return Success
     */
    ingestData(body: IngestDataRequest | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    chatCompletion(body: ChatMessage[] | undefined): Observable<ChatResponse>;
    /**
     * @return Success
     */
    getNames(): Observable<string[]>;
    /**
     * @return Success
     */
    templatesGET(role: string, guid: string): Observable<ProcessInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    templatesPUT(role: string, guid: string, body: ProcessInfo | undefined): Observable<ProcessInfo>;
    /**
     * @return Success
     */
    templatesDELETE(role: string, guid: string): Observable<void>;
    /**
     * @return Success
     */
    templatesAll(role: string): Observable<ProcessInfo[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    templatesPOST(body: ProcessInfo | undefined): Observable<ProcessInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    start(body: StartProcessRequest | undefined): Observable<ProcessInstance>;
    /**
     * @return Success
     */
    stepsGET(stepId: string): Observable<ProcessStepInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    stepsPUT(stepId: string, body: ProcessStepInfo | undefined): Observable<ProcessStepInfo>;
    /**
     * @return Success
     */
    stepsDELETE(stepId: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    stepsPOST(body: ProcessStepInfo | undefined): Observable<ProcessStepInfo>;
    /**
     * @return Success
     */
    processes(instanceId: string): Observable<ProcessInstance>;
    /**
     * @return Success
     */
    instancesAll(userId: string): Observable<ProcessInstance[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    instancesPOST(body: ProcessInstance | undefined): Observable<ProcessInstance>;
    /**
     * @param body (optional) 
     * @return Success
     */
    instancesPUT(instanceId: string, body: ProcessInstance | undefined): Observable<ProcessInstance>;
    /**
     * @return Success
     */
    instancesDELETE(instanceId: string): Observable<void>;
    /**
     * @return Success
     */
    stepInstancesGET(stepInstanceId: string): Observable<ProcessStepInstance>;
    /**
     * @param body (optional) 
     * @return Success
     */
    stepInstancesPUT(stepInstanceId: string, body: ProcessStepInstance | undefined): Observable<ProcessStepInstance>;
    /**
     * @return Success
     */
    stepInstancesDELETE(stepInstanceId: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    stepInstancesPOST(body: ProcessStepInstance | undefined): Observable<ProcessStepInstance>;
    /**
     * Searches a table using text and or semantic search.
     * @param body (optional) 
     * @return Success
     */
    search(body: SearchRequest | undefined): Observable<RetrievedDocument[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getChunks(body: ContentChunkRequest | undefined): Observable<ContentChunk[]>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Creates an agent
     * @param body (optional) 
     * @return Success
     */
    agents(body: Agent | undefined): Observable<ProcessInfo> {
        let url_ = this.baseUrl + "/agents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInfo>;
        }));
    }

    protected processAgents(response: HttpResponseBase): Observable<ProcessInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    agentsAll(): Observable<Agent[]> {
        let url_ = this.baseUrl + "/agents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgentsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgentsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Agent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Agent[]>;
        }));
    }

    protected processAgentsAll(response: HttpResponseBase): Observable<Agent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Agent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates and starts an agent task
     * @param body (optional) 
     * @return Success
     */
    task(body: StartAgentTaskRequest | undefined): Observable<AgentTask> {
        let url_ = this.baseUrl + "/agents/task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgentTask>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgentTask>;
        }));
    }

    protected processTask(response: HttpResponseBase): Observable<AgentTask> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentTask.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTables(): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-tables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetTables(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    removeTable(tableName: string): Observable<string> {
        let url_ = this.baseUrl + "/Database/remove-table/{tableName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRemoveTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTable(body: DatabaseOptions | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Database/reset-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processResetTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEmbeddingsTable(body: DatabaseOptions | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Database/create-embeddings-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmbeddingsTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmbeddingsTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateEmbeddingsTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUniqueTagValues(tableName: string, tag: string): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-unique-tag-values/{tableName}/{tag}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (tag === undefined || tag === null)
            throw new Error("The parameter 'tag' must be defined.");
        url_ = url_.replace("{tag}", encodeURIComponent("" + tag));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniqueTagValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniqueTagValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetUniqueTagValues(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUniqueTagKeys(tableName: string): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-unique-tag-keys/{tableName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniqueTagKeys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniqueTagKeys(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetUniqueTagKeys(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a chat response.
    If SearchOptions are included, search results will be included for the model to use for generation.
    If ProvidedDocumentSources are included, they will be used instead of searching.
     * @param body (optional) 
     * @return Success
     */
    getChatResponse(body: ChatRequest | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/generation/get-chat-response";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processGetChatResponse(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Continues a chat using the chat history object.
    This is a bit experimental, but should allow human in the loop and/or step-by-step animations of what the model is doing in the background.
    When model is finished it will return an Assistant-message with content.
    If this chathistory is returned in another reply then code will see metaData:FinishReason:Stop and will return an empty chathistory object as a reply.
     * @param body (optional) 
     * @return Success
     */
    continueChat(body: ContinueChatRequest | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/generation/continue-chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContinueChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContinueChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processContinueChat(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getChunkers(): Observable<string[]> {
        let url_ = this.baseUrl + "/Ingestion/get-chunkers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChunkers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChunkers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetChunkers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Imports and ingests data
     * @param body (optional) 
     * @return Success
     */
    ingestData(body: IngestDataRequest | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Ingestion/ingest-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIngestData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIngestData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIngestData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chatCompletion(body: ChatMessage[] | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/mock/chatCompletion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChatCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChatCompletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processChatCompletion(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/plugins/get-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    templatesGET(role: string, guid: string): Observable<ProcessInfo> {
        let url_ = this.baseUrl + "/processes/templates/{role}/{guid}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplatesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplatesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInfo>;
        }));
    }

    protected processTemplatesGET(response: HttpResponseBase): Observable<ProcessInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    templatesPUT(role: string, guid: string, body: ProcessInfo | undefined): Observable<ProcessInfo> {
        let url_ = this.baseUrl + "/processes/templates/{role}/{guid}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplatesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplatesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInfo>;
        }));
    }

    protected processTemplatesPUT(response: HttpResponseBase): Observable<ProcessInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    templatesDELETE(role: string, guid: string): Observable<void> {
        let url_ = this.baseUrl + "/processes/templates/{role}/{guid}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplatesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplatesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTemplatesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    templatesAll(role: string): Observable<ProcessInfo[]> {
        let url_ = this.baseUrl + "/processes/templates/{role}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplatesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplatesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInfo[]>;
        }));
    }

    protected processTemplatesAll(response: HttpResponseBase): Observable<ProcessInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    templatesPOST(body: ProcessInfo | undefined): Observable<ProcessInfo> {
        let url_ = this.baseUrl + "/processes/templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplatesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplatesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInfo>;
        }));
    }

    protected processTemplatesPOST(response: HttpResponseBase): Observable<ProcessInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body: StartProcessRequest | undefined): Observable<ProcessInstance> {
        let url_ = this.baseUrl + "/processes/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInstance>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<ProcessInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    stepsGET(stepId: string): Observable<ProcessStepInfo> {
        let url_ = this.baseUrl + "/processes/templates/steps/{stepId}";
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInfo>;
        }));
    }

    protected processStepsGET(response: HttpResponseBase): Observable<ProcessStepInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stepsPUT(stepId: string, body: ProcessStepInfo | undefined): Observable<ProcessStepInfo> {
        let url_ = this.baseUrl + "/processes/templates/steps/{stepId}";
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInfo>;
        }));
    }

    protected processStepsPUT(response: HttpResponseBase): Observable<ProcessStepInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    stepsDELETE(stepId: string): Observable<void> {
        let url_ = this.baseUrl + "/processes/templates/steps/{stepId}";
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stepsPOST(body: ProcessStepInfo | undefined): Observable<ProcessStepInfo> {
        let url_ = this.baseUrl + "/processes/templates/steps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInfo>;
        }));
    }

    protected processStepsPOST(response: HttpResponseBase): Observable<ProcessStepInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    processes(instanceId: string): Observable<ProcessInstance> {
        let url_ = this.baseUrl + "/processes/{instanceId}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcesses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInstance>;
        }));
    }

    protected processProcesses(response: HttpResponseBase): Observable<ProcessInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    instancesAll(userId: string): Observable<ProcessInstance[]> {
        let url_ = this.baseUrl + "/processes/instances/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstancesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstancesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInstance[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInstance[]>;
        }));
    }

    protected processInstancesAll(response: HttpResponseBase): Observable<ProcessInstance[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessInstance.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    instancesPOST(body: ProcessInstance | undefined): Observable<ProcessInstance> {
        let url_ = this.baseUrl + "/processes/instances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstancesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstancesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInstance>;
        }));
    }

    protected processInstancesPOST(response: HttpResponseBase): Observable<ProcessInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    instancesPUT(instanceId: string, body: ProcessInstance | undefined): Observable<ProcessInstance> {
        let url_ = this.baseUrl + "/processes/instances/{instanceId}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstancesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstancesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessInstance>;
        }));
    }

    protected processInstancesPUT(response: HttpResponseBase): Observable<ProcessInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    instancesDELETE(instanceId: string): Observable<void> {
        let url_ = this.baseUrl + "/processes/instances/{instanceId}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstancesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstancesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInstancesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    stepInstancesGET(stepInstanceId: string): Observable<ProcessStepInstance> {
        let url_ = this.baseUrl + "/processes/step-instances/{stepInstanceId}";
        if (stepInstanceId === undefined || stepInstanceId === null)
            throw new Error("The parameter 'stepInstanceId' must be defined.");
        url_ = url_.replace("{stepInstanceId}", encodeURIComponent("" + stepInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepInstancesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepInstancesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInstance>;
        }));
    }

    protected processStepInstancesGET(response: HttpResponseBase): Observable<ProcessStepInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stepInstancesPUT(stepInstanceId: string, body: ProcessStepInstance | undefined): Observable<ProcessStepInstance> {
        let url_ = this.baseUrl + "/processes/step-instances/{stepInstanceId}";
        if (stepInstanceId === undefined || stepInstanceId === null)
            throw new Error("The parameter 'stepInstanceId' must be defined.");
        url_ = url_.replace("{stepInstanceId}", encodeURIComponent("" + stepInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepInstancesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepInstancesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInstance>;
        }));
    }

    protected processStepInstancesPUT(response: HttpResponseBase): Observable<ProcessStepInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    stepInstancesDELETE(stepInstanceId: string): Observable<void> {
        let url_ = this.baseUrl + "/processes/step-instances/{stepInstanceId}";
        if (stepInstanceId === undefined || stepInstanceId === null)
            throw new Error("The parameter 'stepInstanceId' must be defined.");
        url_ = url_.replace("{stepInstanceId}", encodeURIComponent("" + stepInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepInstancesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepInstancesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepInstancesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stepInstancesPOST(body: ProcessStepInstance | undefined): Observable<ProcessStepInstance> {
        let url_ = this.baseUrl + "/processes/step-instances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepInstancesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepInstancesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessStepInstance>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessStepInstance>;
        }));
    }

    protected processStepInstancesPOST(response: HttpResponseBase): Observable<ProcessStepInstance> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessStepInstance.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Searches a table using text and or semantic search.
     * @param body (optional) 
     * @return Success
     */
    search(body: SearchRequest | undefined): Observable<RetrievedDocument[]> {
        let url_ = this.baseUrl + "/retrieval/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrievedDocument[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrievedDocument[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<RetrievedDocument[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RetrievedDocument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getChunks(body: ContentChunkRequest | undefined): Observable<ContentChunk[]> {
        let url_ = this.baseUrl + "/retrieval/get-chunks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChunks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChunks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentChunk[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentChunk[]>;
        }));
    }

    protected processGetChunks(response: HttpResponseBase): Observable<ContentChunk[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentChunk.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Agent implements IAgent {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    options?: { [key: string]: string; } | undefined;

    constructor(data?: IAgent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (_data["options"]) {
                this.options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>this.options)![key] = _data["options"][key];
                }
            }
        }
    }

    static fromJS(data: any): Agent {
        data = typeof data === 'object' ? data : {};
        let result = new Agent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = (<any>this.options)[key];
            }
        }
        return data;
    }
}

export interface IAgent {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    options?: { [key: string]: string; } | undefined;
}

export class AgentTask implements IAgentTask {
    id?: string;
    name?: string | undefined;
    taskPrompt?: string | undefined;
    status?: string | undefined;
    payload?: AgentTaskPayload;
    completedAt?: Date | undefined;
    startedAt?: Date | undefined;
    updatedAt?: Date;

    constructor(data?: IAgentTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.taskPrompt = _data["taskPrompt"];
            this.status = _data["status"];
            this.payload = _data["payload"] ? AgentTaskPayload.fromJS(_data["payload"]) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgentTask {
        data = typeof data === 'object' ? data : {};
        let result = new AgentTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["taskPrompt"] = this.taskPrompt;
        data["status"] = this.status;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAgentTask {
    id?: string;
    name?: string | undefined;
    taskPrompt?: string | undefined;
    status?: string | undefined;
    payload?: AgentTaskPayload;
    completedAt?: Date | undefined;
    startedAt?: Date | undefined;
    updatedAt?: Date;
}

export class AgentTaskPayload implements IAgentTaskPayload {
    state?: { [key: string]: any; } | undefined;
    agents?: string[] | undefined;
    chatHistory?: ChatMessage[] | undefined;

    constructor(data?: IAgentTaskPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["state"]) {
                this.state = {} as any;
                for (let key in _data["state"]) {
                    if (_data["state"].hasOwnProperty(key))
                        (<any>this.state)![key] = _data["state"][key];
                }
            }
            if (Array.isArray(_data["agents"])) {
                this.agents = [] as any;
                for (let item of _data["agents"])
                    this.agents!.push(item);
            }
            if (Array.isArray(_data["chatHistory"])) {
                this.chatHistory = [] as any;
                for (let item of _data["chatHistory"])
                    this.chatHistory!.push(ChatMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgentTaskPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AgentTaskPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.state) {
            data["state"] = {};
            for (let key in this.state) {
                if (this.state.hasOwnProperty(key))
                    (<any>data["state"])[key] = (<any>this.state)[key];
            }
        }
        if (Array.isArray(this.agents)) {
            data["agents"] = [];
            for (let item of this.agents)
                data["agents"].push(item);
        }
        if (Array.isArray(this.chatHistory)) {
            data["chatHistory"] = [];
            for (let item of this.chatHistory)
                data["chatHistory"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgentTaskPayload {
    state?: { [key: string]: any; } | undefined;
    agents?: string[] | undefined;
    chatHistory?: ChatMessage[] | undefined;
}

export class ChatMessage implements IChatMessage {
    role?: string | undefined;
    content?: string | undefined;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        data["content"] = this.content;
        return data;
    }
}

export interface IChatMessage {
    role?: string | undefined;
    content?: string | undefined;
}

export class ChatOptions implements IChatOptions {
    temperature?: number | undefined;
    pluginsToUse?: string[] | undefined;
    pluginUseRequired?: boolean | undefined;
    allowMultiplePluginCallsPerCompletion?: boolean | undefined;
    pluginsAutoInvoke?: boolean | undefined;

    constructor(data?: IChatOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["temperature"];
            if (Array.isArray(_data["pluginsToUse"])) {
                this.pluginsToUse = [] as any;
                for (let item of _data["pluginsToUse"])
                    this.pluginsToUse!.push(item);
            }
            this.pluginUseRequired = _data["pluginUseRequired"];
            this.allowMultiplePluginCallsPerCompletion = _data["allowMultiplePluginCallsPerCompletion"];
            this.pluginsAutoInvoke = _data["pluginsAutoInvoke"];
        }
    }

    static fromJS(data: any): ChatOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ChatOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperature"] = this.temperature;
        if (Array.isArray(this.pluginsToUse)) {
            data["pluginsToUse"] = [];
            for (let item of this.pluginsToUse)
                data["pluginsToUse"].push(item);
        }
        data["pluginUseRequired"] = this.pluginUseRequired;
        data["allowMultiplePluginCallsPerCompletion"] = this.allowMultiplePluginCallsPerCompletion;
        data["pluginsAutoInvoke"] = this.pluginsAutoInvoke;
        return data;
    }
}

export interface IChatOptions {
    temperature?: number | undefined;
    pluginsToUse?: string[] | undefined;
    pluginUseRequired?: boolean | undefined;
    allowMultiplePluginCallsPerCompletion?: boolean | undefined;
    pluginsAutoInvoke?: boolean | undefined;
}

export class ChatRequest implements IChatRequest {
    chatMessages?: ChatMessage[] | undefined;
    providedDocumentSources?: RetrievedDocument[] | undefined;
    chatOptions?: ChatOptions;
    searchOptions?: SearchOptions;

    constructor(data?: IChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["providedDocumentSources"])) {
                this.providedDocumentSources = [] as any;
                for (let item of _data["providedDocumentSources"])
                    this.providedDocumentSources!.push(RetrievedDocument.fromJS(item));
            }
            this.chatOptions = _data["chatOptions"] ? ChatOptions.fromJS(_data["chatOptions"]) : <any>undefined;
            this.searchOptions = _data["searchOptions"] ? SearchOptions.fromJS(_data["searchOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        if (Array.isArray(this.providedDocumentSources)) {
            data["providedDocumentSources"] = [];
            for (let item of this.providedDocumentSources)
                data["providedDocumentSources"].push(item.toJSON());
        }
        data["chatOptions"] = this.chatOptions ? this.chatOptions.toJSON() : <any>undefined;
        data["searchOptions"] = this.searchOptions ? this.searchOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatRequest {
    chatMessages?: ChatMessage[] | undefined;
    providedDocumentSources?: RetrievedDocument[] | undefined;
    chatOptions?: ChatOptions;
    searchOptions?: SearchOptions;
}

export class ChatResponse implements IChatResponse {
    chatMessages?: ChatMessage[] | undefined;
    citations?: RetrievedDocument[] | undefined;
    chatHistoryJson?: string | undefined;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["citations"])) {
                this.citations = [] as any;
                for (let item of _data["citations"])
                    this.citations!.push(RetrievedDocument.fromJS(item));
            }
            this.chatHistoryJson = _data["chatHistoryJson"];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        if (Array.isArray(this.citations)) {
            data["citations"] = [];
            for (let item of this.citations)
                data["citations"].push(item.toJSON());
        }
        data["chatHistoryJson"] = this.chatHistoryJson;
        return data;
    }
}

export interface IChatResponse {
    chatMessages?: ChatMessage[] | undefined;
    citations?: RetrievedDocument[] | undefined;
    chatHistoryJson?: string | undefined;
}

export class ContentChunk implements IContentChunk {
    content?: string | undefined;
    embeddingContent?: string | undefined;
    startIndex?: number;
    endIndex?: number;

    constructor(data?: IContentChunk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.embeddingContent = _data["embeddingContent"];
            this.startIndex = _data["startIndex"];
            this.endIndex = _data["endIndex"];
        }
    }

    static fromJS(data: any): ContentChunk {
        data = typeof data === 'object' ? data : {};
        let result = new ContentChunk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["embeddingContent"] = this.embeddingContent;
        data["startIndex"] = this.startIndex;
        data["endIndex"] = this.endIndex;
        return data;
    }
}

export interface IContentChunk {
    content?: string | undefined;
    embeddingContent?: string | undefined;
    startIndex?: number;
    endIndex?: number;
}

export class ContentChunkRequest implements IContentChunkRequest {
    tableName?: string | undefined;
    uri?: string | undefined;
    startChunk?: number;
    endChunk?: number;

    constructor(data?: IContentChunkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tableName = _data["tableName"];
            this.uri = _data["uri"];
            this.startChunk = _data["startChunk"];
            this.endChunk = _data["endChunk"];
        }
    }

    static fromJS(data: any): ContentChunkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentChunkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["uri"] = this.uri;
        data["startChunk"] = this.startChunk;
        data["endChunk"] = this.endChunk;
        return data;
    }
}

export interface IContentChunkRequest {
    tableName?: string | undefined;
    uri?: string | undefined;
    startChunk?: number;
    endChunk?: number;
}

export class ContinueChatRequest implements IContinueChatRequest {
    previousChatHistoryJson?: string | undefined;
    chatRequest?: ChatRequest;

    constructor(data?: IContinueChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.previousChatHistoryJson = _data["previousChatHistoryJson"];
            this.chatRequest = _data["chatRequest"] ? ChatRequest.fromJS(_data["chatRequest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContinueChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContinueChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousChatHistoryJson"] = this.previousChatHistoryJson;
        data["chatRequest"] = this.chatRequest ? this.chatRequest.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContinueChatRequest {
    previousChatHistoryJson?: string | undefined;
    chatRequest?: ChatRequest;
}

export class DatabaseOptions implements IDatabaseOptions {
    tableName?: string | undefined;
    embeddingsDimensions?: number | undefined;

    constructor(data?: IDatabaseOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tableName = _data["tableName"];
            this.embeddingsDimensions = _data["embeddingsDimensions"];
        }
    }

    static fromJS(data: any): DatabaseOptions {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["embeddingsDimensions"] = this.embeddingsDimensions;
        return data;
    }
}

export interface IDatabaseOptions {
    tableName?: string | undefined;
    embeddingsDimensions?: number | undefined;
}

export class EmbeddingMetaData implements IEmbeddingMetaData {
    uri?: string | undefined;
    createdDateTime?: Date;
    source?: string | undefined;
    sourceChunkNumber?: number;
    sourceTotalChunkNumbers?: number;
    tags?: { [key: string]: string; } | undefined;

    constructor(data?: IEmbeddingMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.source = _data["source"];
            this.sourceChunkNumber = _data["sourceChunkNumber"];
            this.sourceTotalChunkNumbers = _data["sourceTotalChunkNumbers"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): EmbeddingMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new EmbeddingMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["sourceChunkNumber"] = this.sourceChunkNumber;
        data["sourceTotalChunkNumbers"] = this.sourceTotalChunkNumbers;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        return data;
    }
}

export interface IEmbeddingMetaData {
    uri?: string | undefined;
    createdDateTime?: Date;
    source?: string | undefined;
    sourceChunkNumber?: number;
    sourceTotalChunkNumbers?: number;
    tags?: { [key: string]: string; } | undefined;
}

export class IngestDataOptions implements IIngestDataOptions {
    mergeLineIfFewerWordsThan?: number;
    selectedChunkers?: string[] | undefined;
    doPreProcessing?: boolean;

    constructor(data?: IIngestDataOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mergeLineIfFewerWordsThan = _data["mergeLineIfFewerWordsThan"];
            if (Array.isArray(_data["selectedChunkers"])) {
                this.selectedChunkers = [] as any;
                for (let item of _data["selectedChunkers"])
                    this.selectedChunkers!.push(item);
            }
            this.doPreProcessing = _data["doPreProcessing"];
        }
    }

    static fromJS(data: any): IngestDataOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IngestDataOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mergeLineIfFewerWordsThan"] = this.mergeLineIfFewerWordsThan;
        if (Array.isArray(this.selectedChunkers)) {
            data["selectedChunkers"] = [];
            for (let item of this.selectedChunkers)
                data["selectedChunkers"].push(item);
        }
        data["doPreProcessing"] = this.doPreProcessing;
        return data;
    }
}

export interface IIngestDataOptions {
    mergeLineIfFewerWordsThan?: number;
    selectedChunkers?: string[] | undefined;
    doPreProcessing?: boolean;
}

export class IngestDataRequest implements IIngestDataRequest {
    folderPath?: string | undefined;
    metaDataTags?: { [key: string]: string; } | undefined;
    databaseOptions?: DatabaseOptions;
    ingestFromAzureContainerOptions?: IngestFromAzureContainerOptions;
    ingestDataOptions?: IngestDataOptions;

    constructor(data?: IIngestDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderPath = _data["folderPath"];
            if (_data["metaDataTags"]) {
                this.metaDataTags = {} as any;
                for (let key in _data["metaDataTags"]) {
                    if (_data["metaDataTags"].hasOwnProperty(key))
                        (<any>this.metaDataTags)![key] = _data["metaDataTags"][key];
                }
            }
            this.databaseOptions = _data["databaseOptions"] ? DatabaseOptions.fromJS(_data["databaseOptions"]) : <any>undefined;
            this.ingestFromAzureContainerOptions = _data["ingestFromAzureContainerOptions"] ? IngestFromAzureContainerOptions.fromJS(_data["ingestFromAzureContainerOptions"]) : <any>undefined;
            this.ingestDataOptions = _data["ingestDataOptions"] ? IngestDataOptions.fromJS(_data["ingestDataOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IngestDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IngestDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderPath"] = this.folderPath;
        if (this.metaDataTags) {
            data["metaDataTags"] = {};
            for (let key in this.metaDataTags) {
                if (this.metaDataTags.hasOwnProperty(key))
                    (<any>data["metaDataTags"])[key] = (<any>this.metaDataTags)[key];
            }
        }
        data["databaseOptions"] = this.databaseOptions ? this.databaseOptions.toJSON() : <any>undefined;
        data["ingestFromAzureContainerOptions"] = this.ingestFromAzureContainerOptions ? this.ingestFromAzureContainerOptions.toJSON() : <any>undefined;
        data["ingestDataOptions"] = this.ingestDataOptions ? this.ingestDataOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIngestDataRequest {
    folderPath?: string | undefined;
    metaDataTags?: { [key: string]: string; } | undefined;
    databaseOptions?: DatabaseOptions;
    ingestFromAzureContainerOptions?: IngestFromAzureContainerOptions;
    ingestDataOptions?: IngestDataOptions;
}

export class IngestFromAzureContainerOptions implements IIngestFromAzureContainerOptions {
    connectionString?: string | undefined;
    rootContainerName?: string | undefined;
    subFolderPrefix?: string | undefined;
    includeSubfolders?: boolean;

    constructor(data?: IIngestFromAzureContainerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.rootContainerName = _data["rootContainerName"];
            this.subFolderPrefix = _data["subFolderPrefix"];
            this.includeSubfolders = _data["includeSubfolders"];
        }
    }

    static fromJS(data: any): IngestFromAzureContainerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IngestFromAzureContainerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["rootContainerName"] = this.rootContainerName;
        data["subFolderPrefix"] = this.subFolderPrefix;
        data["includeSubfolders"] = this.includeSubfolders;
        return data;
    }
}

export interface IIngestFromAzureContainerOptions {
    connectionString?: string | undefined;
    rootContainerName?: string | undefined;
    subFolderPrefix?: string | undefined;
    includeSubfolders?: boolean;
}

export class ProcessInfo implements IProcessInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    payload?: ProcessPayload;
    steps?: ProcessStepInfo[] | undefined;

    constructor(data?: IProcessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.payload = _data["payload"] ? ProcessPayload.fromJS(_data["payload"]) : <any>undefined;
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(ProcessStepInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProcessInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    payload?: ProcessPayload;
    steps?: ProcessStepInfo[] | undefined;
}

export class ProcessInstance implements IProcessInstance {
    id?: string;
    processId?: string;
    name?: string | undefined;
    status?: string | undefined;
    startedBy?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    updatedAt?: Date;
    stepInstances?: ProcessStepInstance[] | undefined;
    payload?: ProcessPayload;

    constructor(data?: IProcessInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processId = _data["processId"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.startedBy = _data["startedBy"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["stepInstances"])) {
                this.stepInstances = [] as any;
                for (let item of _data["stepInstances"])
                    this.stepInstances!.push(ProcessStepInstance.fromJS(item));
            }
            this.payload = _data["payload"] ? ProcessPayload.fromJS(_data["payload"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processId"] = this.processId;
        data["name"] = this.name;
        data["status"] = this.status;
        data["startedBy"] = this.startedBy;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.stepInstances)) {
            data["stepInstances"] = [];
            for (let item of this.stepInstances)
                data["stepInstances"].push(item.toJSON());
        }
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessInstance {
    id?: string;
    processId?: string;
    name?: string | undefined;
    status?: string | undefined;
    startedBy?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    updatedAt?: Date;
    stepInstances?: ProcessStepInstance[] | undefined;
    payload?: ProcessPayload;
}

export class ProcessPayload implements IProcessPayload {
    options?: { [key: string]: any; } | undefined;
    startingState?: { [key: string]: any; } | undefined;
    endingState?: { [key: string]: any; } | undefined;

    constructor(data?: IProcessPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["options"]) {
                this.options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>this.options)![key] = _data["options"][key];
                }
            }
            if (_data["startingState"]) {
                this.startingState = {} as any;
                for (let key in _data["startingState"]) {
                    if (_data["startingState"].hasOwnProperty(key))
                        (<any>this.startingState)![key] = _data["startingState"][key];
                }
            }
            if (_data["endingState"]) {
                this.endingState = {} as any;
                for (let key in _data["endingState"]) {
                    if (_data["endingState"].hasOwnProperty(key))
                        (<any>this.endingState)![key] = _data["endingState"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProcessPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = (<any>this.options)[key];
            }
        }
        if (this.startingState) {
            data["startingState"] = {};
            for (let key in this.startingState) {
                if (this.startingState.hasOwnProperty(key))
                    (<any>data["startingState"])[key] = (<any>this.startingState)[key];
            }
        }
        if (this.endingState) {
            data["endingState"] = {};
            for (let key in this.endingState) {
                if (this.endingState.hasOwnProperty(key))
                    (<any>data["endingState"])[key] = (<any>this.endingState)[key];
            }
        }
        return data;
    }
}

export interface IProcessPayload {
    options?: { [key: string]: any; } | undefined;
    startingState?: { [key: string]: any; } | undefined;
    endingState?: { [key: string]: any; } | undefined;
}

export class ProcessStepInfo implements IProcessStepInfo {
    id?: string;
    processId?: string;
    name?: string | undefined;
    stepClassName?: string | undefined;
    predecessorStepIds?: string[] | undefined;
    successorStepIds?: string[] | undefined;
    payload?: ProcessPayload;

    constructor(data?: IProcessStepInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processId = _data["processId"];
            this.name = _data["name"];
            this.stepClassName = _data["stepClassName"];
            if (Array.isArray(_data["predecessorStepIds"])) {
                this.predecessorStepIds = [] as any;
                for (let item of _data["predecessorStepIds"])
                    this.predecessorStepIds!.push(item);
            }
            if (Array.isArray(_data["successorStepIds"])) {
                this.successorStepIds = [] as any;
                for (let item of _data["successorStepIds"])
                    this.successorStepIds!.push(item);
            }
            this.payload = _data["payload"] ? ProcessPayload.fromJS(_data["payload"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessStepInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessStepInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processId"] = this.processId;
        data["name"] = this.name;
        data["stepClassName"] = this.stepClassName;
        if (Array.isArray(this.predecessorStepIds)) {
            data["predecessorStepIds"] = [];
            for (let item of this.predecessorStepIds)
                data["predecessorStepIds"].push(item);
        }
        if (Array.isArray(this.successorStepIds)) {
            data["successorStepIds"] = [];
            for (let item of this.successorStepIds)
                data["successorStepIds"].push(item);
        }
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessStepInfo {
    id?: string;
    processId?: string;
    name?: string | undefined;
    stepClassName?: string | undefined;
    predecessorStepIds?: string[] | undefined;
    successorStepIds?: string[] | undefined;
    payload?: ProcessPayload;
}

export class ProcessStepInstance implements IProcessStepInstance {
    id?: string;
    name?: string | undefined;
    stepClassName?: string | undefined;
    processInstanceId?: string;
    processStepId?: string;
    status?: string | undefined;
    startedAt?: Date | undefined;
    completedAt?: Date | undefined;
    payload?: ProcessPayload;

    constructor(data?: IProcessStepInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.stepClassName = _data["stepClassName"];
            this.processInstanceId = _data["processInstanceId"];
            this.processStepId = _data["processStepId"];
            this.status = _data["status"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.payload = _data["payload"] ? ProcessPayload.fromJS(_data["payload"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessStepInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessStepInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["stepClassName"] = this.stepClassName;
        data["processInstanceId"] = this.processInstanceId;
        data["processStepId"] = this.processStepId;
        data["status"] = this.status;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessStepInstance {
    id?: string;
    name?: string | undefined;
    stepClassName?: string | undefined;
    processInstanceId?: string;
    processStepId?: string;
    status?: string | undefined;
    startedAt?: Date | undefined;
    completedAt?: Date | undefined;
    payload?: ProcessPayload;
}

export class RetrievedDocument implements IRetrievedDocument {
    uri?: string | undefined;
    readonly tableName?: string | undefined;
    content?: string | undefined;
    readonly embeddingContent?: string | undefined;
    readonly startIndex?: number;
    readonly endIndex?: number;
    title?: string | undefined;
    metaData?: EmbeddingMetaData;
    chunkId?: string | undefined;
    rerankScore?: number | undefined;
    additionalData?: { [key: string]: string; } | undefined;
    contentAfter?: string | undefined;
    contentBefore?: string | undefined;

    constructor(data?: IRetrievedDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            (<any>this).tableName = _data["tableName"];
            this.content = _data["content"];
            (<any>this).embeddingContent = _data["embeddingContent"];
            (<any>this).startIndex = _data["startIndex"];
            (<any>this).endIndex = _data["endIndex"];
            this.title = _data["title"];
            this.metaData = _data["metaData"] ? EmbeddingMetaData.fromJS(_data["metaData"]) : <any>undefined;
            this.chunkId = _data["chunkId"];
            this.rerankScore = _data["rerankScore"];
            if (_data["additionalData"]) {
                this.additionalData = {} as any;
                for (let key in _data["additionalData"]) {
                    if (_data["additionalData"].hasOwnProperty(key))
                        (<any>this.additionalData)![key] = _data["additionalData"][key];
                }
            }
            this.contentAfter = _data["contentAfter"];
            this.contentBefore = _data["contentBefore"];
        }
    }

    static fromJS(data: any): RetrievedDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RetrievedDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["tableName"] = this.tableName;
        data["content"] = this.content;
        data["embeddingContent"] = this.embeddingContent;
        data["startIndex"] = this.startIndex;
        data["endIndex"] = this.endIndex;
        data["title"] = this.title;
        data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
        data["chunkId"] = this.chunkId;
        data["rerankScore"] = this.rerankScore;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    (<any>data["additionalData"])[key] = (<any>this.additionalData)[key];
            }
        }
        data["contentAfter"] = this.contentAfter;
        data["contentBefore"] = this.contentBefore;
        return data;
    }
}

export interface IRetrievedDocument {
    uri?: string | undefined;
    tableName?: string | undefined;
    content?: string | undefined;
    embeddingContent?: string | undefined;
    startIndex?: number;
    endIndex?: number;
    title?: string | undefined;
    metaData?: EmbeddingMetaData;
    chunkId?: string | undefined;
    rerankScore?: number | undefined;
    additionalData?: { [key: string]: string; } | undefined;
    contentAfter?: string | undefined;
    contentBefore?: string | undefined;
}

export class SearchOptions implements ISearchOptions {
    embeddingsTableName?: string | undefined;
    itemsToRetrieve?: number;
    itemsToSkip?: number;
    contentMustIncludeWords?: string[] | undefined;
    contentMustNotIncludeWords?: string[] | undefined;
    metaDataIncludeWhenContainsAll?: { [key: string]: string[]; } | undefined;
    metaDataIncludeWhenContainsAny?: { [key: string]: string[]; } | undefined;
    metaDataExcludeWhenContainsAll?: { [key: string]: string[]; } | undefined;
    metaDataExcludeWhenContainsAny?: { [key: string]: string[]; } | undefined;
    semanticSearchContent?: string | undefined;
    includeContentChunksAfter?: number;
    includeContentChunksBefore?: number;
    useSemanticReRanker?: boolean;
    semanticRankerCandidatesToRetrieve?: number;
    useSemanticCaptions?: boolean;
    semanticSearchGenerateSummaryOfNMessages?: number;

    constructor(data?: ISearchOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.embeddingsTableName = _data["embeddingsTableName"];
            this.itemsToRetrieve = _data["itemsToRetrieve"];
            this.itemsToSkip = _data["itemsToSkip"];
            if (Array.isArray(_data["contentMustIncludeWords"])) {
                this.contentMustIncludeWords = [] as any;
                for (let item of _data["contentMustIncludeWords"])
                    this.contentMustIncludeWords!.push(item);
            }
            if (Array.isArray(_data["contentMustNotIncludeWords"])) {
                this.contentMustNotIncludeWords = [] as any;
                for (let item of _data["contentMustNotIncludeWords"])
                    this.contentMustNotIncludeWords!.push(item);
            }
            if (_data["metaDataIncludeWhenContainsAll"]) {
                this.metaDataIncludeWhenContainsAll = {} as any;
                for (let key in _data["metaDataIncludeWhenContainsAll"]) {
                    if (_data["metaDataIncludeWhenContainsAll"].hasOwnProperty(key))
                        (<any>this.metaDataIncludeWhenContainsAll)![key] = _data["metaDataIncludeWhenContainsAll"][key] !== undefined ? _data["metaDataIncludeWhenContainsAll"][key] : [];
                }
            }
            if (_data["metaDataIncludeWhenContainsAny"]) {
                this.metaDataIncludeWhenContainsAny = {} as any;
                for (let key in _data["metaDataIncludeWhenContainsAny"]) {
                    if (_data["metaDataIncludeWhenContainsAny"].hasOwnProperty(key))
                        (<any>this.metaDataIncludeWhenContainsAny)![key] = _data["metaDataIncludeWhenContainsAny"][key] !== undefined ? _data["metaDataIncludeWhenContainsAny"][key] : [];
                }
            }
            if (_data["metaDataExcludeWhenContainsAll"]) {
                this.metaDataExcludeWhenContainsAll = {} as any;
                for (let key in _data["metaDataExcludeWhenContainsAll"]) {
                    if (_data["metaDataExcludeWhenContainsAll"].hasOwnProperty(key))
                        (<any>this.metaDataExcludeWhenContainsAll)![key] = _data["metaDataExcludeWhenContainsAll"][key] !== undefined ? _data["metaDataExcludeWhenContainsAll"][key] : [];
                }
            }
            if (_data["metaDataExcludeWhenContainsAny"]) {
                this.metaDataExcludeWhenContainsAny = {} as any;
                for (let key in _data["metaDataExcludeWhenContainsAny"]) {
                    if (_data["metaDataExcludeWhenContainsAny"].hasOwnProperty(key))
                        (<any>this.metaDataExcludeWhenContainsAny)![key] = _data["metaDataExcludeWhenContainsAny"][key] !== undefined ? _data["metaDataExcludeWhenContainsAny"][key] : [];
                }
            }
            this.semanticSearchContent = _data["semanticSearchContent"];
            this.includeContentChunksAfter = _data["includeContentChunksAfter"];
            this.includeContentChunksBefore = _data["includeContentChunksBefore"];
            this.useSemanticReRanker = _data["useSemanticReRanker"];
            this.semanticRankerCandidatesToRetrieve = _data["semanticRankerCandidatesToRetrieve"];
            this.useSemanticCaptions = _data["useSemanticCaptions"];
            this.semanticSearchGenerateSummaryOfNMessages = _data["semanticSearchGenerateSummaryOfNMessages"];
        }
    }

    static fromJS(data: any): SearchOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["embeddingsTableName"] = this.embeddingsTableName;
        data["itemsToRetrieve"] = this.itemsToRetrieve;
        data["itemsToSkip"] = this.itemsToSkip;
        if (Array.isArray(this.contentMustIncludeWords)) {
            data["contentMustIncludeWords"] = [];
            for (let item of this.contentMustIncludeWords)
                data["contentMustIncludeWords"].push(item);
        }
        if (Array.isArray(this.contentMustNotIncludeWords)) {
            data["contentMustNotIncludeWords"] = [];
            for (let item of this.contentMustNotIncludeWords)
                data["contentMustNotIncludeWords"].push(item);
        }
        if (this.metaDataIncludeWhenContainsAll) {
            data["metaDataIncludeWhenContainsAll"] = {};
            for (let key in this.metaDataIncludeWhenContainsAll) {
                if (this.metaDataIncludeWhenContainsAll.hasOwnProperty(key))
                    (<any>data["metaDataIncludeWhenContainsAll"])[key] = (<any>this.metaDataIncludeWhenContainsAll)[key];
            }
        }
        if (this.metaDataIncludeWhenContainsAny) {
            data["metaDataIncludeWhenContainsAny"] = {};
            for (let key in this.metaDataIncludeWhenContainsAny) {
                if (this.metaDataIncludeWhenContainsAny.hasOwnProperty(key))
                    (<any>data["metaDataIncludeWhenContainsAny"])[key] = (<any>this.metaDataIncludeWhenContainsAny)[key];
            }
        }
        if (this.metaDataExcludeWhenContainsAll) {
            data["metaDataExcludeWhenContainsAll"] = {};
            for (let key in this.metaDataExcludeWhenContainsAll) {
                if (this.metaDataExcludeWhenContainsAll.hasOwnProperty(key))
                    (<any>data["metaDataExcludeWhenContainsAll"])[key] = (<any>this.metaDataExcludeWhenContainsAll)[key];
            }
        }
        if (this.metaDataExcludeWhenContainsAny) {
            data["metaDataExcludeWhenContainsAny"] = {};
            for (let key in this.metaDataExcludeWhenContainsAny) {
                if (this.metaDataExcludeWhenContainsAny.hasOwnProperty(key))
                    (<any>data["metaDataExcludeWhenContainsAny"])[key] = (<any>this.metaDataExcludeWhenContainsAny)[key];
            }
        }
        data["semanticSearchContent"] = this.semanticSearchContent;
        data["includeContentChunksAfter"] = this.includeContentChunksAfter;
        data["includeContentChunksBefore"] = this.includeContentChunksBefore;
        data["useSemanticReRanker"] = this.useSemanticReRanker;
        data["semanticRankerCandidatesToRetrieve"] = this.semanticRankerCandidatesToRetrieve;
        data["useSemanticCaptions"] = this.useSemanticCaptions;
        data["semanticSearchGenerateSummaryOfNMessages"] = this.semanticSearchGenerateSummaryOfNMessages;
        return data;
    }
}

export interface ISearchOptions {
    embeddingsTableName?: string | undefined;
    itemsToRetrieve?: number;
    itemsToSkip?: number;
    contentMustIncludeWords?: string[] | undefined;
    contentMustNotIncludeWords?: string[] | undefined;
    metaDataIncludeWhenContainsAll?: { [key: string]: string[]; } | undefined;
    metaDataIncludeWhenContainsAny?: { [key: string]: string[]; } | undefined;
    metaDataExcludeWhenContainsAll?: { [key: string]: string[]; } | undefined;
    metaDataExcludeWhenContainsAny?: { [key: string]: string[]; } | undefined;
    semanticSearchContent?: string | undefined;
    includeContentChunksAfter?: number;
    includeContentChunksBefore?: number;
    useSemanticReRanker?: boolean;
    semanticRankerCandidatesToRetrieve?: number;
    useSemanticCaptions?: boolean;
    semanticSearchGenerateSummaryOfNMessages?: number;
}

export class SearchRequest implements ISearchRequest {
    searchOptions?: SearchOptions;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchOptions = _data["searchOptions"] ? SearchOptions.fromJS(_data["searchOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchOptions"] = this.searchOptions ? this.searchOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISearchRequest {
    searchOptions?: SearchOptions;
}

export class StartAgentTaskRequest implements IStartAgentTaskRequest {
    taskPrompt?: string | undefined;
    name?: string | undefined;
    agents?: string[] | undefined;
    terminationStrategyInfo?: TerminationStrategyInfo;
    options?: { [key: string]: string; } | undefined;

    constructor(data?: IStartAgentTaskRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskPrompt = _data["taskPrompt"];
            this.name = _data["name"];
            if (Array.isArray(_data["agents"])) {
                this.agents = [] as any;
                for (let item of _data["agents"])
                    this.agents!.push(item);
            }
            this.terminationStrategyInfo = _data["terminationStrategyInfo"] ? TerminationStrategyInfo.fromJS(_data["terminationStrategyInfo"]) : <any>undefined;
            if (_data["options"]) {
                this.options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>this.options)![key] = _data["options"][key];
                }
            }
        }
    }

    static fromJS(data: any): StartAgentTaskRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartAgentTaskRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskPrompt"] = this.taskPrompt;
        data["name"] = this.name;
        if (Array.isArray(this.agents)) {
            data["agents"] = [];
            for (let item of this.agents)
                data["agents"].push(item);
        }
        data["terminationStrategyInfo"] = this.terminationStrategyInfo ? this.terminationStrategyInfo.toJSON() : <any>undefined;
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = (<any>this.options)[key];
            }
        }
        return data;
    }
}

export interface IStartAgentTaskRequest {
    taskPrompt?: string | undefined;
    name?: string | undefined;
    agents?: string[] | undefined;
    terminationStrategyInfo?: TerminationStrategyInfo;
    options?: { [key: string]: string; } | undefined;
}

export class StartProcessRequest implements IStartProcessRequest {
    name?: string | undefined;
    startedBy?: string | undefined;
    processId?: string;
    payload?: ProcessPayload;
    stepIdsWithPayload?: { [key: string]: ProcessPayload; } | undefined;

    constructor(data?: IStartProcessRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startedBy = _data["startedBy"];
            this.processId = _data["processId"];
            this.payload = _data["payload"] ? ProcessPayload.fromJS(_data["payload"]) : <any>undefined;
            if (_data["stepIdsWithPayload"]) {
                this.stepIdsWithPayload = {} as any;
                for (let key in _data["stepIdsWithPayload"]) {
                    if (_data["stepIdsWithPayload"].hasOwnProperty(key))
                        (<any>this.stepIdsWithPayload)![key] = _data["stepIdsWithPayload"][key] ? ProcessPayload.fromJS(_data["stepIdsWithPayload"][key]) : new ProcessPayload();
                }
            }
        }
    }

    static fromJS(data: any): StartProcessRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartProcessRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startedBy"] = this.startedBy;
        data["processId"] = this.processId;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        if (this.stepIdsWithPayload) {
            data["stepIdsWithPayload"] = {};
            for (let key in this.stepIdsWithPayload) {
                if (this.stepIdsWithPayload.hasOwnProperty(key))
                    (<any>data["stepIdsWithPayload"])[key] = this.stepIdsWithPayload[key] ? this.stepIdsWithPayload[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IStartProcessRequest {
    name?: string | undefined;
    startedBy?: string | undefined;
    processId?: string;
    payload?: ProcessPayload;
    stepIdsWithPayload?: { [key: string]: ProcessPayload; } | undefined;
}

export class TerminationStrategyInfo implements ITerminationStrategyInfo {
    type?: string | undefined;
    payload?: { [key: string]: any; } | undefined;

    constructor(data?: ITerminationStrategyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (_data["payload"]) {
                this.payload = {} as any;
                for (let key in _data["payload"]) {
                    if (_data["payload"].hasOwnProperty(key))
                        (<any>this.payload)![key] = _data["payload"][key];
                }
            }
        }
    }

    static fromJS(data: any): TerminationStrategyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TerminationStrategyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.payload) {
            data["payload"] = {};
            for (let key in this.payload) {
                if (this.payload.hasOwnProperty(key))
                    (<any>data["payload"])[key] = (<any>this.payload)[key];
            }
        }
        return data;
    }
}

export interface ITerminationStrategyInfo {
    type?: string | undefined;
    payload?: { [key: string]: any; } | undefined;
}

export class ApiClientException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiClientException = true;

    static isApiClientException(obj: any): obj is ApiClientException {
        return obj.isApiClientException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiClientException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}