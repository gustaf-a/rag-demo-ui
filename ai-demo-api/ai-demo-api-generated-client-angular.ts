//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @return Success
     */
    getNames(): Observable<string[]>;
    /**
     * @return Success
     */
    getTables(): Observable<string[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    removeTable(body: DatabaseOptions | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    resetTable(body: DatabaseOptions | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createEmbeddingsTable(body: DatabaseOptions | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getUniqueTagValues(tag: string, body: DatabaseOptions | undefined): Observable<string[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    getUniqueTagKeys(body: DatabaseOptions | undefined): Observable<string[]>;
    /**
     * Gets a chat response.
    If SearchOptions are included, search results will be included for the model to use for generation.
    If ProvidedDocumentSources are included, they will be used instead of searching.
     * @param body (optional) 
     * @return Success
     */
    getChatResponse(body: ChatRequest | undefined): Observable<ChatResponse>;
    /**
     * Continues a chat using the chat history object.
    This is a bit experimental, but should allow human in the loop and/or step-by-step animations of what the model is doing in the background.
    When model is finished it will return an Assistant-message with content.
    If this chathistory is returned in another reply then code will see metaData:FinishReason:Stop and will return an empty chathistory object as a reply.
     * @param body (optional) 
     * @return Success
     */
    continueChat(body: ContinueChatRequest | undefined): Observable<ChatResponse>;
    /**
     * @return Success
     */
    getChunkers(): Observable<string[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    ingestData(body: IngestDataRequest | undefined): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    chatCompletion(body: ChatMessage[] | undefined): Observable<ChatResponse>;
    /**
     * @return Success
     */
    getNames2(): Observable<string[]>;
    /**
     * Searches a table using text and or semantic search.
     * @param body (optional) 
     * @return Success
     */
    search(body: SearchRequest | undefined): Observable<RetrievedDocument[]>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/agents/get-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTables(): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-tables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTables(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetTables(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTable(body: DatabaseOptions | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Database/remove-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRemoveTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTable(body: DatabaseOptions | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Database/reset-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processResetTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEmbeddingsTable(body: DatabaseOptions | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Database/create-embeddings-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmbeddingsTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmbeddingsTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateEmbeddingsTable(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUniqueTagValues(tag: string, body: DatabaseOptions | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-unique-tag-values/{tag}";
        if (tag === undefined || tag === null)
            throw new Error("The parameter 'tag' must be defined.");
        url_ = url_.replace("{tag}", encodeURIComponent("" + tag));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniqueTagValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniqueTagValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetUniqueTagValues(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUniqueTagKeys(body: DatabaseOptions | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/Database/get-unique-tag-keys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniqueTagKeys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniqueTagKeys(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetUniqueTagKeys(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a chat response.
    If SearchOptions are included, search results will be included for the model to use for generation.
    If ProvidedDocumentSources are included, they will be used instead of searching.
     * @param body (optional) 
     * @return Success
     */
    getChatResponse(body: ChatRequest | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/generation/get-chat-response";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processGetChatResponse(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Continues a chat using the chat history object.
    This is a bit experimental, but should allow human in the loop and/or step-by-step animations of what the model is doing in the background.
    When model is finished it will return an Assistant-message with content.
    If this chathistory is returned in another reply then code will see metaData:FinishReason:Stop and will return an empty chathistory object as a reply.
     * @param body (optional) 
     * @return Success
     */
    continueChat(body: ContinueChatRequest | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/generation/continue-chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContinueChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContinueChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processContinueChat(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getChunkers(): Observable<string[]> {
        let url_ = this.baseUrl + "/Ingestion/get-chunkers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChunkers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChunkers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetChunkers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ingestData(body: IngestDataRequest | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Ingestion/ingest-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIngestData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIngestData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIngestData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    chatCompletion(body: ChatMessage[] | undefined): Observable<ChatResponse> {
        let url_ = this.baseUrl + "/mock/chatCompletion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChatCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChatCompletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatResponse>;
        }));
    }

    protected processChatCompletion(response: HttpResponseBase): Observable<ChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNames2(): Observable<string[]> {
        let url_ = this.baseUrl + "/plugins/get-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNames2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNames2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetNames2(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Searches a table using text and or semantic search.
     * @param body (optional) 
     * @return Success
     */
    search(body: SearchRequest | undefined): Observable<RetrievedDocument[]> {
        let url_ = this.baseUrl + "/retrieval/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetrievedDocument[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetrievedDocument[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<RetrievedDocument[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RetrievedDocument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ChatMessage implements IChatMessage {
    role?: string | undefined;
    content?: string | undefined;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        data["content"] = this.content;
        return data;
    }
}

export interface IChatMessage {
    role?: string | undefined;
    content?: string | undefined;
}

export class ChatOptions implements IChatOptions {
    temperature?: number | undefined;
    pluginsToUse?: string[] | undefined;
    pluginUseRequired?: boolean | undefined;
    allowMultiplePluginCallsPerCompletion?: boolean | undefined;
    pluginsAutoInvoke?: boolean | undefined;

    constructor(data?: IChatOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["temperature"];
            if (Array.isArray(_data["pluginsToUse"])) {
                this.pluginsToUse = [] as any;
                for (let item of _data["pluginsToUse"])
                    this.pluginsToUse!.push(item);
            }
            this.pluginUseRequired = _data["pluginUseRequired"];
            this.allowMultiplePluginCallsPerCompletion = _data["allowMultiplePluginCallsPerCompletion"];
            this.pluginsAutoInvoke = _data["pluginsAutoInvoke"];
        }
    }

    static fromJS(data: any): ChatOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ChatOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperature"] = this.temperature;
        if (Array.isArray(this.pluginsToUse)) {
            data["pluginsToUse"] = [];
            for (let item of this.pluginsToUse)
                data["pluginsToUse"].push(item);
        }
        data["pluginUseRequired"] = this.pluginUseRequired;
        data["allowMultiplePluginCallsPerCompletion"] = this.allowMultiplePluginCallsPerCompletion;
        data["pluginsAutoInvoke"] = this.pluginsAutoInvoke;
        return data;
    }
}

export interface IChatOptions {
    temperature?: number | undefined;
    pluginsToUse?: string[] | undefined;
    pluginUseRequired?: boolean | undefined;
    allowMultiplePluginCallsPerCompletion?: boolean | undefined;
    pluginsAutoInvoke?: boolean | undefined;
}

export class ChatRequest implements IChatRequest {
    chatMessages?: ChatMessage[] | undefined;
    providedDocumentSources?: RetrievedDocument[] | undefined;
    chatOptions?: ChatOptions;
    searchOptions?: SearchOptions;

    constructor(data?: IChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["providedDocumentSources"])) {
                this.providedDocumentSources = [] as any;
                for (let item of _data["providedDocumentSources"])
                    this.providedDocumentSources!.push(RetrievedDocument.fromJS(item));
            }
            this.chatOptions = _data["chatOptions"] ? ChatOptions.fromJS(_data["chatOptions"]) : <any>undefined;
            this.searchOptions = _data["searchOptions"] ? SearchOptions.fromJS(_data["searchOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        if (Array.isArray(this.providedDocumentSources)) {
            data["providedDocumentSources"] = [];
            for (let item of this.providedDocumentSources)
                data["providedDocumentSources"].push(item.toJSON());
        }
        data["chatOptions"] = this.chatOptions ? this.chatOptions.toJSON() : <any>undefined;
        data["searchOptions"] = this.searchOptions ? this.searchOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatRequest {
    chatMessages?: ChatMessage[] | undefined;
    providedDocumentSources?: RetrievedDocument[] | undefined;
    chatOptions?: ChatOptions;
    searchOptions?: SearchOptions;
}

export class ChatResponse implements IChatResponse {
    chatMessages?: ChatMessage[] | undefined;
    citations?: RetrievedDocument[] | undefined;
    chatHistoryJson?: string | undefined;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessage.fromJS(item));
            }
            if (Array.isArray(_data["citations"])) {
                this.citations = [] as any;
                for (let item of _data["citations"])
                    this.citations!.push(RetrievedDocument.fromJS(item));
            }
            this.chatHistoryJson = _data["chatHistoryJson"];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        if (Array.isArray(this.citations)) {
            data["citations"] = [];
            for (let item of this.citations)
                data["citations"].push(item.toJSON());
        }
        data["chatHistoryJson"] = this.chatHistoryJson;
        return data;
    }
}

export interface IChatResponse {
    chatMessages?: ChatMessage[] | undefined;
    citations?: RetrievedDocument[] | undefined;
    chatHistoryJson?: string | undefined;
}

export class ContinueChatRequest implements IContinueChatRequest {
    previousChatHistoryJson?: string | undefined;
    chatRequest?: ChatRequest;

    constructor(data?: IContinueChatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.previousChatHistoryJson = _data["previousChatHistoryJson"];
            this.chatRequest = _data["chatRequest"] ? ChatRequest.fromJS(_data["chatRequest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContinueChatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContinueChatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousChatHistoryJson"] = this.previousChatHistoryJson;
        data["chatRequest"] = this.chatRequest ? this.chatRequest.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContinueChatRequest {
    previousChatHistoryJson?: string | undefined;
    chatRequest?: ChatRequest;
}

export class DatabaseOptions implements IDatabaseOptions {
    tableName?: string | undefined;
    embeddingsDimensions?: number | undefined;

    constructor(data?: IDatabaseOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tableName = _data["tableName"];
            this.embeddingsDimensions = _data["embeddingsDimensions"];
        }
    }

    static fromJS(data: any): DatabaseOptions {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["embeddingsDimensions"] = this.embeddingsDimensions;
        return data;
    }
}

export interface IDatabaseOptions {
    tableName?: string | undefined;
    embeddingsDimensions?: number | undefined;
}

export class EmbeddingMetaData implements IEmbeddingMetaData {
    uri?: string | undefined;
    createdDateTime?: Date;
    source?: string | undefined;
    tags?: { [key: string]: string; } | undefined;

    constructor(data?: IEmbeddingMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.source = _data["source"];
            if (_data["tags"]) {
                this.tags = {} as any;
                for (let key in _data["tags"]) {
                    if (_data["tags"].hasOwnProperty(key))
                        (<any>this.tags)![key] = _data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): EmbeddingMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new EmbeddingMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["source"] = this.source;
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    (<any>data["tags"])[key] = (<any>this.tags)[key];
            }
        }
        return data;
    }
}

export interface IEmbeddingMetaData {
    uri?: string | undefined;
    createdDateTime?: Date;
    source?: string | undefined;
    tags?: { [key: string]: string; } | undefined;
}

export class IngestDataOptions implements IIngestDataOptions {
    mergeLineIfFewerWordsThan?: number;
    selectedChunkers?: string[] | undefined;

    constructor(data?: IIngestDataOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mergeLineIfFewerWordsThan = _data["mergeLineIfFewerWordsThan"];
            if (Array.isArray(_data["selectedChunkers"])) {
                this.selectedChunkers = [] as any;
                for (let item of _data["selectedChunkers"])
                    this.selectedChunkers!.push(item);
            }
        }
    }

    static fromJS(data: any): IngestDataOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IngestDataOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mergeLineIfFewerWordsThan"] = this.mergeLineIfFewerWordsThan;
        if (Array.isArray(this.selectedChunkers)) {
            data["selectedChunkers"] = [];
            for (let item of this.selectedChunkers)
                data["selectedChunkers"].push(item);
        }
        return data;
    }
}

export interface IIngestDataOptions {
    mergeLineIfFewerWordsThan?: number;
    selectedChunkers?: string[] | undefined;
}

export class IngestDataRequest implements IIngestDataRequest {
    folderPath?: string | undefined;
    metaDataTags?: { [key: string]: string; } | undefined;
    databaseOptions?: DatabaseOptions;
    ingestFromAzureContainerOptions?: IngestFromAzureContainerOptions;
    ingestDataOptions?: IngestDataOptions;

    constructor(data?: IIngestDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderPath = _data["folderPath"];
            if (_data["metaDataTags"]) {
                this.metaDataTags = {} as any;
                for (let key in _data["metaDataTags"]) {
                    if (_data["metaDataTags"].hasOwnProperty(key))
                        (<any>this.metaDataTags)![key] = _data["metaDataTags"][key];
                }
            }
            this.databaseOptions = _data["databaseOptions"] ? DatabaseOptions.fromJS(_data["databaseOptions"]) : <any>undefined;
            this.ingestFromAzureContainerOptions = _data["ingestFromAzureContainerOptions"] ? IngestFromAzureContainerOptions.fromJS(_data["ingestFromAzureContainerOptions"]) : <any>undefined;
            this.ingestDataOptions = _data["ingestDataOptions"] ? IngestDataOptions.fromJS(_data["ingestDataOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IngestDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IngestDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderPath"] = this.folderPath;
        if (this.metaDataTags) {
            data["metaDataTags"] = {};
            for (let key in this.metaDataTags) {
                if (this.metaDataTags.hasOwnProperty(key))
                    (<any>data["metaDataTags"])[key] = (<any>this.metaDataTags)[key];
            }
        }
        data["databaseOptions"] = this.databaseOptions ? this.databaseOptions.toJSON() : <any>undefined;
        data["ingestFromAzureContainerOptions"] = this.ingestFromAzureContainerOptions ? this.ingestFromAzureContainerOptions.toJSON() : <any>undefined;
        data["ingestDataOptions"] = this.ingestDataOptions ? this.ingestDataOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIngestDataRequest {
    folderPath?: string | undefined;
    metaDataTags?: { [key: string]: string; } | undefined;
    databaseOptions?: DatabaseOptions;
    ingestFromAzureContainerOptions?: IngestFromAzureContainerOptions;
    ingestDataOptions?: IngestDataOptions;
}

export class IngestFromAzureContainerOptions implements IIngestFromAzureContainerOptions {
    connectionString?: string | undefined;
    containerName?: string | undefined;

    constructor(data?: IIngestFromAzureContainerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.containerName = _data["containerName"];
        }
    }

    static fromJS(data: any): IngestFromAzureContainerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IngestFromAzureContainerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["containerName"] = this.containerName;
        return data;
    }
}

export interface IIngestFromAzureContainerOptions {
    connectionString?: string | undefined;
    containerName?: string | undefined;
}

export class RetrievedDocument implements IRetrievedDocument {
    uri?: string | undefined;
    readonly tableName?: string | undefined;
    content?: string | undefined;
    title?: string | undefined;
    metaData?: EmbeddingMetaData;
    chunkId?: string | undefined;
    rerankScore?: number | undefined;
    additionalData?: { [key: string]: string; } | undefined;

    constructor(data?: IRetrievedDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uri = _data["uri"];
            (<any>this).tableName = _data["tableName"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.metaData = _data["metaData"] ? EmbeddingMetaData.fromJS(_data["metaData"]) : <any>undefined;
            this.chunkId = _data["chunkId"];
            this.rerankScore = _data["rerankScore"];
            if (_data["additionalData"]) {
                this.additionalData = {} as any;
                for (let key in _data["additionalData"]) {
                    if (_data["additionalData"].hasOwnProperty(key))
                        (<any>this.additionalData)![key] = _data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): RetrievedDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RetrievedDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["tableName"] = this.tableName;
        data["content"] = this.content;
        data["title"] = this.title;
        data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
        data["chunkId"] = this.chunkId;
        data["rerankScore"] = this.rerankScore;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    (<any>data["additionalData"])[key] = (<any>this.additionalData)[key];
            }
        }
        return data;
    }
}

export interface IRetrievedDocument {
    uri?: string | undefined;
    tableName?: string | undefined;
    content?: string | undefined;
    title?: string | undefined;
    metaData?: EmbeddingMetaData;
    chunkId?: string | undefined;
    rerankScore?: number | undefined;
    additionalData?: { [key: string]: string; } | undefined;
}

export class SearchOptions implements ISearchOptions {
    embeddingsTableName?: string | undefined;
    itemsToRetrieve?: number;
    itemsToSkip?: number;
    contentMustIncludeWords?: string[] | undefined;
    contentMustNotIncludeWords?: string[] | undefined;
    metaDataInclude?: { [key: string]: string[]; } | undefined;
    metaDataExclude?: { [key: string]: string[]; } | undefined;
    semanticSearchContent?: string | undefined;
    useSemanticReRanker?: boolean;
    semanticRankerCandidatesToRetrieve?: number;
    useSemanticCaptions?: boolean;
    semanticSearchGenerateSummaryOfNMessages?: number;

    constructor(data?: ISearchOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.embeddingsTableName = _data["embeddingsTableName"];
            this.itemsToRetrieve = _data["itemsToRetrieve"];
            this.itemsToSkip = _data["itemsToSkip"];
            if (Array.isArray(_data["contentMustIncludeWords"])) {
                this.contentMustIncludeWords = [] as any;
                for (let item of _data["contentMustIncludeWords"])
                    this.contentMustIncludeWords!.push(item);
            }
            if (Array.isArray(_data["contentMustNotIncludeWords"])) {
                this.contentMustNotIncludeWords = [] as any;
                for (let item of _data["contentMustNotIncludeWords"])
                    this.contentMustNotIncludeWords!.push(item);
            }
            if (_data["metaDataInclude"]) {
                this.metaDataInclude = {} as any;
                for (let key in _data["metaDataInclude"]) {
                    if (_data["metaDataInclude"].hasOwnProperty(key))
                        (<any>this.metaDataInclude)![key] = _data["metaDataInclude"][key] !== undefined ? _data["metaDataInclude"][key] : [];
                }
            }
            if (_data["metaDataExclude"]) {
                this.metaDataExclude = {} as any;
                for (let key in _data["metaDataExclude"]) {
                    if (_data["metaDataExclude"].hasOwnProperty(key))
                        (<any>this.metaDataExclude)![key] = _data["metaDataExclude"][key] !== undefined ? _data["metaDataExclude"][key] : [];
                }
            }
            this.semanticSearchContent = _data["semanticSearchContent"];
            this.useSemanticReRanker = _data["useSemanticReRanker"];
            this.semanticRankerCandidatesToRetrieve = _data["semanticRankerCandidatesToRetrieve"];
            this.useSemanticCaptions = _data["useSemanticCaptions"];
            this.semanticSearchGenerateSummaryOfNMessages = _data["semanticSearchGenerateSummaryOfNMessages"];
        }
    }

    static fromJS(data: any): SearchOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["embeddingsTableName"] = this.embeddingsTableName;
        data["itemsToRetrieve"] = this.itemsToRetrieve;
        data["itemsToSkip"] = this.itemsToSkip;
        if (Array.isArray(this.contentMustIncludeWords)) {
            data["contentMustIncludeWords"] = [];
            for (let item of this.contentMustIncludeWords)
                data["contentMustIncludeWords"].push(item);
        }
        if (Array.isArray(this.contentMustNotIncludeWords)) {
            data["contentMustNotIncludeWords"] = [];
            for (let item of this.contentMustNotIncludeWords)
                data["contentMustNotIncludeWords"].push(item);
        }
        if (this.metaDataInclude) {
            data["metaDataInclude"] = {};
            for (let key in this.metaDataInclude) {
                if (this.metaDataInclude.hasOwnProperty(key))
                    (<any>data["metaDataInclude"])[key] = (<any>this.metaDataInclude)[key];
            }
        }
        if (this.metaDataExclude) {
            data["metaDataExclude"] = {};
            for (let key in this.metaDataExclude) {
                if (this.metaDataExclude.hasOwnProperty(key))
                    (<any>data["metaDataExclude"])[key] = (<any>this.metaDataExclude)[key];
            }
        }
        data["semanticSearchContent"] = this.semanticSearchContent;
        data["useSemanticReRanker"] = this.useSemanticReRanker;
        data["semanticRankerCandidatesToRetrieve"] = this.semanticRankerCandidatesToRetrieve;
        data["useSemanticCaptions"] = this.useSemanticCaptions;
        data["semanticSearchGenerateSummaryOfNMessages"] = this.semanticSearchGenerateSummaryOfNMessages;
        return data;
    }
}

export interface ISearchOptions {
    embeddingsTableName?: string | undefined;
    itemsToRetrieve?: number;
    itemsToSkip?: number;
    contentMustIncludeWords?: string[] | undefined;
    contentMustNotIncludeWords?: string[] | undefined;
    metaDataInclude?: { [key: string]: string[]; } | undefined;
    metaDataExclude?: { [key: string]: string[]; } | undefined;
    semanticSearchContent?: string | undefined;
    useSemanticReRanker?: boolean;
    semanticRankerCandidatesToRetrieve?: number;
    useSemanticCaptions?: boolean;
    semanticSearchGenerateSummaryOfNMessages?: number;
}

export class SearchRequest implements ISearchRequest {
    searchOptions?: SearchOptions;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchOptions = _data["searchOptions"] ? SearchOptions.fromJS(_data["searchOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchOptions"] = this.searchOptions ? this.searchOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISearchRequest {
    searchOptions?: SearchOptions;
}

export class ApiClientException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiClientException = true;

    static isApiClientException(obj: any): obj is ApiClientException {
        return obj.isApiClientException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiClientException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}